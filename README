Ευάγγελος Νεαμονίτης
ΑΜ: 1115201400123

Έχουν Υλοποιηθεί όλα τα ζητούμενα με την bonus υλοποίηση και το προαιρετικό ερώτημα (dump)

Για compilation: make

Για εκτελεση (οι σημαιες με οποιαδηποτε σειρα και η -o προαιρετικη):
 ./werhauz -o Operations -h1 Hash_entries1 -h2 Hash_entries2 -s Bucketsize -c Tarrif_Config_file

Δοκιμαστηκε με Valgrind και δεν υπαρχουν memory leaks.

 Αν εχει δοθει Operations αρχειο, τοτε εκτελουνται ολες οι εντολες που περιεχει και μετα ο ελεγχος δινεται
 στον χρηστη μεσω του prompt. Διαφορετικα ο χρηστης περνει κατευθειαν τον ελεγχο μεσω του prompt.

 Δομες:

 Hashtables: Υπαρχουν δυο hashtables με αριθμο θεσεων και μεγεθος bucket που δινονται απο τη γραμμη εντολων.
 			 Εχουν υλοποιηθει με τον τροπο που φαινεται στο σχημα με τη διαφορα οτι εχει γινει η bonus υλοποιηση
 			 και οι λιστες απο CDRS του καθενος δειχνουν με δεικτες στις εγγραφες.Ο καθε Hashtable αποτελειται απο 
 			 εναν πινακα απο δεικτες λιστες απο buckets. Καθε bucket εχει εναν πινακα απο δομες που περιεχουν
 			 τηλεφωνο και δεικτη σε λιστα απο CDRS. Ο καθε κομβος της λιστας εχει εναν πινακα απο CDRS το μεγεθος
 			 του οποιου εχει γινει defined.

Bin Max Heap: Ο καθε κομβος του σωρου αποτελειται απο τηλεφωνο και το ποσο που εχει ξοδεψει ο συνδρομητης με το 
			  τηλεφωνο αυτο.Η διατηρηση του σωρου γινεται με βαση το ποσο. Ενα CDR υπολογιζεται για εισαγωγη στο 
			  max heap εαν το fault condition του ειναι της μορφης 2xx. Το ποσο που χρεωνεται υπολογιζεται με βαση
			  το configuration file που δινεται απο την γραμμη εντολων. Οι κομβοι του heap εχουν δεικτη στον πατερα καθως
			  αυτο βοηθαει στην συγκριση και τη μεταφορα των κομβων κατα το heapify.

Συναρτησεις:

1)insert: Εισαγει στους δυο Hashtables το CDR οι δυο πινακες δειχνουν σε αυτο αποφευγοντας τα duplicates. Οσον αφορα
		  το σωρο αν το cdr που ειναι να εισαχθει δεν εχει fault condition διαφορο του 2xx τοτε αν υπαρχει το τηλεφωνο
		  του καλουντα στο σωρο γινεται update του ποσου που εχει ξοδεψει, αλλιως δημηιουργειται νεος κομβος.Η εισαγωγη στο
		  σωρο γινεται με τη βοηθεια της διαδυκης αξιας του επομενου αριθμου κομβου προς εισαγωγη (αν εχω 5 κομβους στο δεντρο μιλαμε για τον 6ο).Υπαρχει περιγραφη για αυτο και στα σχολια του κωδικα.

2)delete: Για την διαγραφη γινεται αναζητηση του Hashtable για χρηστη με το τηλεφωνο που δοθηκε. Αν βρεθει γινεται
		  Αναζητηση στα CDRs του και αν βρεθει εγγραφη με το ιδιο id ο δεικτης προς την εγγραφη αυτη γινεται NULL.
		  Στον Hashtable2 διατηρειται η πληροφορια.Αν ενας κομβος της CDR list αδειασει τοτε διαγραφεται για οικονομια χωρου.

3,4)find lookup: Η find λειτουργει για ολες τις περιπτωσεις με τον τροπο που ζητηθηκε.Λειτουργει με ημερομηνια και ωρα, μονο 
		μεημερομηνια και μονο με ωρα. Ειδικοτερα αν time1> time2 λειτουργει κανονικα( πχ οπως ειπωθηκε για 11:00 και 07:00 θα τυπωθουν 11:00 12:00 13:00 14:00 ... 06:00 7:00). Η lookup λειτουργει με τον ιδιο ακριβως τροπο.


5)indist: Φτιαχνει μια λιστα με τα τηλεφωνα που επικοινωνησε ο caller1 μια λιστα με τα τηλεφωνα με τα οποια επικοινωνησε 
		  ο caller2 τις εννωνει σε μια και μετα ελεγχεται ποιοι απο αυτους που περιεχονται στην ενοποιημενη λιστα εχουν 
		  επικοινωνησει μεταξυ τους. οσοι δεν εχουν επικοινωνησει μεταξυ τους εκτυπωνονται. Η επιλογη με τις 3 λιστες εγινε 
		  για να περιοριστουν οι ελεγχοι καθως εχοντας στο τελος μια λιστα με τους κοινους συνδρομητες κανουμε αρκετα λιγοτερους
		  ελεγχους απο το να ψαχνουμε για τον καθε συνδρομητη που εχει επικοινωνησει ο caller 1 αν εχει επικοινωνησει μαζι του
		  και ο caller2. Επισης με τις λιστες αποφευγω την χρηση realloc σε πινακα.

6)topdest: Φτιαχνει λιστα με ολους τους προορισμους που εχει καλεσει ο caller και ποσες φορες καλεσε τον καθενα.Στο τελος 
		   Ψαχνει τη λιστα για το μεγιστο της και το τυπωνει.Παλι με τη λιστα αποφευγεται η χρηση realloc σε πινακα.

7)top:	Δημιουργει ενα βοηθητικο heap για το οποιο ακολουθειται ο εξης αλγοριθμος:
	Τυπωσε τη ριζα του βασικου δεντρου(αφου ειναι σιγουρα ο top συνδρομητης) και βαλε τα παιδια της στο βοηθητικο heap.
	οσο το ποσο που ζητηθηκε δεν εχει εξαντληθει τυπωσε τη ριζα του βοηθητικου σωρου διεγραψε την και βαλε τα παιδια του κομβου απο το βασικο σωρο που αντιστοιχουσε στη ριζα
	στο βοηθητικο σωρο. 
	

8)bye: με τη bye δεν τερματιζεται το προγραμμα. Αδειαζουν οι πινακες και ο σωρος και απελευθερωνεται ολη η μνημη.
	   Οι πινακες παραμενουν initialized και ο σωρος γινεται NULL. μετα την εντολη bye μπορουν να γινουν νεες insert 
	   και να δοθουν κανονικα ολες οι εντολες.

9)print: τυπωνεται ο hashtablex με τον τροπο που ζητηθηκε 

10)dump: Ο hashtableX τυπωνεται σε ενα αρχειο με τη μορφη insert cdr_record. Ετσι αν δοθει μετα το αρχειο αυτο σαν operations 
		 με την σημαια -o τα cdr του πινακα επανερχονται στη μνημη.










